go.property("size", 3)
go.property("color", vmath.vector4(1, 1, 1, 1))
go.property("velocity", vmath.vector3(0))
go.property("health", 100)
go.property("max_health", 100)
go.property("collision_timeout", 0.5)
go.property("initial_slowdown", 1)
go.property("type", 0)

local function emitter_state_change(self, id, emitter, state)
	if emitter == hash("death_fx") and state == particlefx.EMITTER_STATE_POSTSPAWN then
		go.delete("mesh_container")
		go.delete()
	elseif emitter == hash("death_fx") and state == particlefx.EMITTER_STATE_SPAWNING then
		local color = go.get("mesh_container#mesh", "color")
		particlefx.set_constant("#asteroid_pfx", "death_fx", "tint", self.color)
		particlefx.set_constant("#asteroid_pfx", "death_fx", "scale", vmath.vector4(self.size/3))
	--[[elseif emitter == hash("emitter") and state == particlefx.EMITTER_STATE_SPAWNING then
		local color = go.get("mesh_container#mesh", "color")
		particlefx.set_constant("#damage_pfx", "emitter", "tint", color)]]--
	end
end

local function death(self) 
	--particlefx.stop("#damage_pfx")
	particlefx.play("#asteroid_pfx", emitter_state_change)	
	msg.post("#asteroid_gui", "set_health", {health = 0, max_health = self.max_health})
	if self.size > 1 then
		local c = math.random(1,3)
		for i=1,c do
			local velocity = go.get("#co" .. self.size, "linear_velocity")
			local angular_velocity = go.get("#co" .. self.size, "angular_velocity")
			local lower_x = -velocity.y/3 < 1+velocity.y/3 and -velocity.y/3 or 1+velocity.y/3
			local higher_x = (not(-velocity.y/3 < 1+velocity.y/3)) and -velocity.y/3 or 1+velocity.y/3
			local lower_y = -velocity.x/3 < 1+velocity.x/3 and -velocity.x/3 or 1+velocity.x/3
			local higher_y = (not(-velocity.x/3 < 1+velocity.x/3)) and -velocity.x/3 or 1+velocity.x/3
			local d_vel = vmath.vector3(10+math.random(lower_x, higher_x), 
			10+math.random(lower_y, higher_y), 0)
			local props = {}
			props[hash("/base_asteroid")] = {size = self.size-1, type = self.type}
			props[hash("/mesh_container")] = {size = self.size-1}
			local ids = collectionfactory.create("/manager#asteroid_collection_factory", go.get_position(), nil, props, 1)
			msg.post(ids[hash("/base_asteroid")], "set_velocities", {linear_velocity = velocity + d_vel, angular_velocity = angular_velocity})
		end
	end
end

local function play_damage_pfx(self)
	if self.damage_pfx_gate <= 0 then 
		particlefx.play("#damage_pfx")
		particlefx.set_constant("#damage_pfx", "emitter", "tint", self.color)
		self.damage_pfx_gate = 0.1
	end
end

function init(self)
	self.dying = false
	self.min_life = 1.5
	self.health = 100 * self.size
	self.max_health = 100 * self.size
	self.damage_pfx_gate = 0
	self.screen_dimensions = vmath.vector3(1920, 1017, 0)
	msg.post("#asteroid_gui", "set_scale", {scale = vmath.vector3(self.size / 2.5)})

	msg.post("#co1", "disable")
	msg.post("#co2", "disable")
	msg.post("#co3", "disable")
	msg.post("#co_death", "disable")
	msg.post("#co1_kinematic", "disable")
	msg.post("#co2_kinematic", "disable")
	msg.post("#co3_kinematic", "disable")
	msg.post("#co" .. self.size, "enable")	
	msg.post("/manager", "enemy_created")

	go.set("mesh_container#mesh", "color", vmath.vector4(0.25, 0.4, 0.5, 1))
	self.color = vmath.vector4(0.25, 0.4, 0.5, 1)
	self.type_init = base_init
	self.type_update = base_update
	self.type_message_handling = base_message_handling
	if self.type == 1 then
		self.type_init = magnetic_init
		self.type_update = magnetic_update
		self.type_message_handling = magnetic_message_handling
	end
	self.type_init(self)

	self.subscribers = {}
end

function update(self, dt)
	local pos = go.get_position()
	msg.post("#asteroid_gui", "set_data", {pos = pos, color = go.get("mesh_container#mesh", "color")})

	if self.collision_timeout > 0 then
		self.collision_timeout = self.collision_timeout - dt
	end

	self.velocity = go.get("#co" .. self.size, "linear_velocity")
	local angular_velocity = go.get("#co" .. self.size, "angular_velocity")
	local rot = go.get_rotation("mesh_container")
	rot = rot * vmath.quat_rotation_x(math.sin(angular_velocity.z)*dt) * vmath.quat_rotation_y(math.cos(angular_velocity.z)*dt)
	go.set_rotation(rot, "mesh_container")
	if self.health <= 0 and not self.dying then
		msg.post("#co" .. self.size, "disable")	
		msg.post("#co_death", "enable")
		go.set("#co_death", "linear_velocity", self.velocity)
		go.set("#co_death", "angular_velocity", angular_velocity)
		self.dying = true
		death(self)
	end

	if vmath.length(self.velocity) > 600 and not self.dying then
		msg.post("#co" .. self.size, "apply_force", {force = -self.velocity * dt * 1000, position = pos})
	end

	local div = 1
	if self.initial_slowdown > 0 then
		div = div + self.initial_slowdown
		self.initial_slowdown = self.initial_slowdown - dt/3
	end
	local force = (vmath.vector3(self.screen_dimensions.x/2, self.screen_dimensions.y/2, 0) - pos) / div * dt * 80
	if not (pos.x < self.screen_dimensions.x * (3/4) and pos.x > self.screen_dimensions.x / 4 and pos.y < self.screen_dimensions.y * (3/4) and pos.y > self.screen_dimensions.y / 4) then
		msg.post("#co" .. self.size, "apply_force", {force = force, position = pos})
	else 
		msg.post("#co" .. self.size, "apply_force", {force = force * 0.1, position = pos})
	end
	if self.damage_pfx_gate > 0 then self.damage_pfx_gate = self.damage_pfx_gate-dt end

	self.type_update(self, dt)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("contact_point_response") then
		if message.other_group == hash("ship") and self.collision_timeout <= 0 then
			self.collision_timeout = 0.5
			self.health = self.health - vmath.length(message.relative_velocity) / go.get("#co" .. self.size, "mass")
			msg.post("#co" .. self.size, "apply_force", {force = message.normal * (10 + vmath.length(message.relative_velocity)), 
			position = message.position})
			msg.post("#asteroid_gui", "set_health", {health = self.health, max_health = self.max_health})
			play_damage_pfx(self)
		end	
	elseif message_id == hash("update_screen_dimensions") then
		self.screen_dimensions = message.screen_dimensions
	elseif message_id == hash("damage_asteroid") then
		self.health = self.health - message.damage
		play_damage_pfx(self)
		msg.post("#asteroid_gui", "set_health", {health = self.health, max_health = self.max_health})
	elseif message_id == hash("subscribe") then
		self.subscribers[#self.subscribers+1] = sender
	elseif message_id == hash("unsubscribe") then
		for k,v in pairs(self.subscribers)do
			if v == sender then
				table.remove(self.subscribers, k)
				break
			end
		end
	elseif message_id == hash("set_velocities") then
		msg.post("#co" .. self.size, "enable")
		go.set("#co" .. self.size, "linear_velocity", message.linear_velocity)
		go.set("#co" .. self.size, "angular_velocity", message.angular_velocity)
	end
	self.type_message_handling(self, message_id, message, sender)
end

function final(self)
	for i,v in ipairs(self.subscribers) do 
		msg.post(v, "unsubscribe")
	end
	msg.post("/manager", "enemy_destroyed")
end

function base_init(self) end
function base_update(self, dt) end
function base_message_handling(self, message_id, message, sender) end

function magnetic_init(self) 
	go.set("mesh_container#mesh", "color", vmath.vector4(1, 0, 0, 1))
	self.color = vmath.vector4(1, 0, 0, 1)
	go.animate("mesh_container#mesh", "color", go.PLAYBACK_LOOP_PINGPONG, vmath.vector4(0, 0, 1, 1), go.EASING_INOUTSINE, 5)
end

function magnetic_update(self, dt) 
	msg.post("/manager", "target_closest_ship", {pos = go.get_position(), range = 10000, dt = dt})
end

function magnetic_message_handling(self, message_id, message, sender) 
	if message_id == hash("target_ship_response") then
		if message.found then
			local vector_to_target = vmath.normalize(go.get_position(message.ship) - go.get_position())
			local dist = vmath.length(go.get_position(message.ship) - go.get_position())
			local force = vector_to_target * (math.pow(go.get("#co" .. self.size, "mass"), 2) / math.pow(dist, 1.75) * message.dt) * 1000000000
			if vmath.length(force) > 500 then 
				force = vmath.normalize(force) * 500
			end
			msg.post("#co" .. self.size, "apply_force", {
				force = force, 
				position = go.get_position()
			})
		end
	end
end