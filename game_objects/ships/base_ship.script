require "modules.ships.laser_cutter"
require "modules.ships.battleship"
require "modules.ships.missile_cruiser"
require "modules.ships.minelayer"
require "modules.ships.healer_placeholder"
require "modules.utils"
require "modules.subscriber_module"
require "modules.model_switcher"

go.property("target_pos", vmath.vector3(960, 500, 0))
go.property("heading", vmath.vector3(0, 1, 0))
go.property("speed", 300)
go.property("visibility_range", 150)
go.property("evasion", 2)
go.property("targeting_range", 500)
go.property("level", 1)
go.property("sub_level", 1)
go.property("type", 1)
go.property("health", 100)
go.property("max_health", 100)
go.property("health_percentage", 100)
go.property("armor", 0)
go.property("cooldown_mult", 1)
go.property("is_flagship", false)
go.property("stat_tracker", hash("."))
go.property("class_1", hash(""))
go.property("class_2", hash(""))
go.property("class_3", hash(""))

local function emitter_state_change(self, id, emitter, state)
	if emitter == hash("death_fx") and state == particlefx.EMITTER_STATE_POSTSPAWN then
		go.delete()
	end
end

function init(self)
	self.d_steer = 0
	self.collision_timeout = 0.5
	self.init_type = battleship_init
	if self.type == 2 then
		self.init_type = laser_cutter_init
	elseif self.type == 3 then
		self.init_type = missile_cruiser_init
	elseif self.type == 4 then
		self.init_type = minelayer_init
	elseif self.type == 5 then
		self.init_type = healer_placeholder_init
	end
	self.init_type(self)
	self.health = self.max_health * (self.health_percentage/100)
	msg.post(self.stat_tracker, "set_health", {health = self.health / self.max_health})

	model_switch(self.type, SHIP)
	
	msg.post("/manager", "ship_created")
	init_subscriber_module(self)
end

function final(self)
	notify_subscribers_of_destruction(self)
	msg.post(self.stat_tracker, "set_cooldown", {cooldown = 0})
	msg.post(self.stat_tracker, "set_health", {health = 0})
	msg.post(self.stat_tracker, "death")
	msg.post("/manager", "ship_destroyed")
end

function update(self, dt)
	self.collision_timeout = self.collision_timeout - dt
	local max_x, max_y = 1920, 1017
	local pos = go.get_position()
	
	if pos.x > max_x then
		pos.x = max_x
	elseif pos.x < 0 then
		pos.x = 0
	end

	if pos.y > max_y then
		pos.y = max_y
	elseif pos.y < 0 then
		pos.y = 0
	end
	
	self.target_pos = go.get_position("/fleet/target_position")
	local dist_to_target = vmath.length(self.target_pos - pos)
	local vec_to_target = vmath.normalize(self.target_pos - pos)
	if dist_to_target == 0 then
		vec_to_target = vmath.vector3(0, 1, 0)
	end
	if self.heading.x ~= self.heading.x then
		self.heading = vmath.vector3(0, 1, 0)
	end
	if vec_to_target.x ~= vec_to_target.x then print("asd") end
	--print(self.evasion * dt, self.heading, vec_to_target, vmath.slerp(self.evasion * dt, self.heading, vec_to_target))
	local d_steer = vmath.cross(vmath.slerp(self.evasion * dt, self.heading, vec_to_target), self.heading).z * 2000
	self.d_steer = vmath.lerp(self.evasion * dt, self.d_steer, d_steer)
	
	self.heading = vmath.normalize(vmath.slerp(self.evasion * dt, self.heading, vec_to_target))
	local angle = math.deg(math.atan2(self.heading.y, self.heading.x)) - 90
	local rot_z = vmath.quat_rotation_z(math.rad(angle))
	local rot_y = vmath.quat_rotation_y(math.rad(self.d_steer))
	go.set_rotation(rot_z * rot_y)

	for i=-3,2 do
		local target = pos + vmath.vector3(math.cos(math.rad(i*30+angle+90+15)), math.sin(math.rad(i*30+angle+90+15)), 0) * self.visibility_range
		local result = physics.raycast(pos, target, { hash("ship_cast") })
		if result ~= nil then
			--msg.post("@render:", "draw_line", {start_point = pos, end_point = result.position, color = vmath.vector4(0, 1, 0, 1)})
			local dist = (self.visibility_range-vmath.length(pos - result.position))/self.visibility_range
			if dist > 1 then dist = 1 end
			self.heading = vmath.normalize(vmath.slerp(self.evasion * dt * dist, 
							self.heading, vmath.normalize(pos - result.position)))
		else
			--msg.post("@render:", "draw_line", {start_point = pos, end_point = target, color = vmath.vector4(1, 0, 0, 1)})
		end
	end
	local res_speed = self.speed
	if dist_to_target < self.visibility_range - 50 then
		res_speed = self.speed * dist_to_target/(self.visibility_range - 50) + 50
	end
	pos = pos + self.heading * res_speed * dt
	go.set_position(pos)

	msg.post(self.stat_tracker, "set_health", {health = self.health / self.max_health})

	self.update_type(self, dt)
end

function on_message(self, message_id, message, sender)
	on_subscription_message(self, message_id, message, sender)
	self.message_type(self, message_id, message, sender)
	if message_id == hash("contact_point_response") then
		if message.other_group == hash("asteroid") and self.collision_timeout <= 0 then
			self.collision_timeout = 0.5
			local damage = 5 + (vmath.length(message.relative_velocity) * (1+message.other_mass/3)) / 35
			damage = clamp(damage - self.armor, 0, damage)
			self.health = self.health - damage
			if self.health <= 0 then
				msg.post("main:/manager#camera_controller", "camera_shake", {time = 1, intensity = 50})
				particlefx.play("#ship_pfx", emitter_state_change)	
			end
			msg.post("main:/manager#camera_controller", "bonk_camera", {pos = message.normal * damage})
		end
	elseif message_id == hash("heal") then
		self.health = math.min(self.health + message.value, self.max_health)
	end
end





