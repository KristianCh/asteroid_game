require "modules.ships.laser_cutter"
require "modules.ships.battleship"
require "modules.ships.missile_cruiser"
require "modules.ships.minelayer"
require "modules.ships.mine_healer"
require "modules.ships.gravity_tether"
require "modules.ships.graviton_trapper"
require "modules.ships.energy_nuker"
require "modules.ships.ram"
require "modules.ships.fleet_carrier"
require "modules.ships.kamikaze_carrier"
require "modules.utils"
require "modules.model_switcher"

go.property("target_pos", vmath.vector3(960, 500, 0))
go.property("impact_resistance", 1)
go.property("heading", vmath.vector3(0, 1, 0))
go.property("speed", 300)
go.property("visibility_range", 150)
go.property("evasion", 2)
go.property("targeting_range", 500)
go.property("level", 1)
go.property("sub_level", 1)
go.property("type", 1)
go.property("health", 100)
go.property("max_health", 100)
go.property("health_percentage", 100)
go.property("armor", 0)
go.property("cooldown_mult", 1)
go.property("drone_bonus", 0)
go.property("drone_range", 0)
go.property("is_flagship", false)
go.property("stat_tracker", hash("."))
go.property("class_1", hash(""))
go.property("class_2", hash(""))
go.property("class_3", hash(""))

local function emitter_state_change(self, id, emitter, state)
	if emitter == hash("death_fx") and state == particlefx.EMITTER_STATE_POSTSPAWN then
		go.delete()
	end
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.d_steer = 0
	self.collision_timeout = 0.5
	self.follow_target = true
	self.show_raycast = false
	self.init_type = battleship_init
	self.final_type = function(self) end
	if self.type == 2 then
		self.init_type = laser_cutter_init
	elseif self.type == 3 then
		self.init_type = missile_cruiser_init
	elseif self.type == 4 then
		self.init_type = minelayer_init
	elseif self.type == 5 then
		self.init_type = mine_healer_init
	elseif self.type == 6 then
		self.init_type = gravity_tether_init
	elseif self.type == 7 then
		self.init_type = graviton_trapper_init
	elseif self.type == 8 then
		self.init_type = energy_nuker_init
	elseif self.type == 9 then
		self.init_type = ram_init
	elseif self.type == 10 then
		self.init_type = fleet_carrier_init
	elseif self.type == 11 then
		self.init_type = kamikaze_carrier_init
	end
	self.init_type(self)
	self.health = self.max_health * (self.health_percentage/100)
	msg.post(self.stat_tracker, "set_health", {health = self.health / self.max_health})

	model_switch(self.type, SHIP)
	
	msg.post("/manager", "ship_created")
end

function final(self)
	self.final_type(self)
	msg.post(self.stat_tracker, "set_cooldown", {cooldown = 0})
	msg.post(self.stat_tracker, "set_health", {health = 0})
	msg.post(self.stat_tracker, "death")
	msg.post("/manager", "ship_destroyed")
end

function update(self, dt)
	self.collision_timeout = self.collision_timeout - dt
	local max_x, max_y = WIDTH, HEIGHT
	local pos = go.get_position()
	
	if pos.x > max_x then
		pos.x = max_x
	elseif pos.x < 0 then
		pos.x = 0
	end

	if pos.y > max_y then
		pos.y = max_y
	elseif pos.y < 0 then
		pos.y = 0
	end
	
	self.target_pos = go.get_position("/fleet/target_position")
	local dist_to_target = vmath.length(self.target_pos - pos)
	local vec_to_target = vmath.normalize(self.target_pos - pos)
	if dist_to_target == 0 then
		vec_to_target = vmath.vector3(0, 1, 0)
	end
	if self.heading.x ~= self.heading.x then
		self.heading = vmath.vector3(0, 1, 0)
	end
	local d_steer = vmath.cross(vmath.lerp(self.evasion * dt, self.heading, vec_to_target), self.heading).z * 2000
	local raycast_targets = { hash("ship_cast") }
	if self.follow_target then
		self.heading = vmath.normalize(vmath.slerp(self.evasion * dt, self.heading, vec_to_target))
	else
		d_steer = 0
	end
	if not self.follow_target then
		raycast_targets = { hash("ship_cast"), hash("asteroid") }
	end
	
	self.d_steer = vmath.lerp(self.evasion * dt, self.d_steer, d_steer)
	
	local angle = math.deg(math.atan2(self.heading.y, self.heading.x)) - 90
	local rot_z = vmath.quat_rotation_z(math.rad(angle))
	local rot_y = vmath.quat_rotation_y(math.rad(self.d_steer))
	go.set_rotation(rot_z * rot_y)

	for i=-3,2 do
		local target = pos + vmath.vector3(math.cos(math.rad(i*30+angle+90+15)), math.sin(math.rad(i*30+angle+90+15)), 0) * self.visibility_range
		local result = physics.raycast(pos, target, raycast_targets)
		if result ~= nil then
			if self.show_raycast then
				msg.post("@render:", "draw_line", {start_point = pos, end_point = result.position, color = vmath.vector4(0, 1, 0, 1)})
			end
			local dist = (self.visibility_range-vmath.length(pos - result.position))/self.visibility_range
			if dist > 1 then dist = 1 end
			self.heading = vmath.normalize(vmath.slerp(self.evasion * dt * dist, 
							self.heading, vmath.normalize(pos - result.position)))
		else
			if self.show_raycast then
				msg.post("@render:", "draw_line", {start_point = pos, end_point = target, color = vmath.vector4(1, 0, 0, 1)})

			end
		end
	end
	local res_speed = self.speed
	if dist_to_target < self.visibility_range - 50 then
		res_speed = self.speed * dist_to_target/(self.visibility_range - 50) + 50
	end
	pos = pos + self.heading * res_speed * dt
	go.set_position(pos)

	msg.post(self.stat_tracker, "set_health", {health = self.health / self.max_health})

	self.update_type(self, dt)
end

function process_damage(self, damage) 
	damage = clamp(damage - self.armor, 0, damage)
	self.health = self.health - damage
	if self.health <= 0 then
		msg.post("main:/manager#camera_controller", "camera_shake", {time = 1, intensity = 50})
		particlefx.play("#ship_pfx", emitter_state_change)	
	end
end

function on_message(self, message_id, message, sender)
	on_subscription_message(self, message_id, message, sender)
	self.message_type(self, message_id, message, sender)
	
	if message_id == hash("contact_point_response") then
		if message.other_group == hash("asteroid") and self.collision_timeout <= 0 then
			self.collision_timeout = 0.5
			local damage = 5 + (vmath.length(message.relative_velocity) * (1+message.other_mass/3)) / 35
			damage = damage * self.impact_resistance
			process_damage(self, damage)
			msg.post("main:/manager#camera_controller", "bonk_camera", {pos = message.normal * damage})
		end
	elseif message_id == hash("heal") then
		self.health = math.min(self.health + message.value, self.max_health)
	elseif message_id == hash("damage") then
		process_damage(self, message.damage)
	end
end

function on_input(self, action_id, action)
	if action_id == hash("mouse_left") then
		if action.pressed then
			self.follow_target = false
		elseif action.released then
			self.follow_target = true
		end
	elseif action_id == hash("r") and action.released then
		self.show_raycast = not self.show_raycast
	end
end





