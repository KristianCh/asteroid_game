go.property("target_pos", vmath.vector3(960, 500, 0))
go.property("heading", vmath.vector3(0, 1, 0))
go.property("speed", 250)
go.property("visibility_range", 150)
go.property("evasion", 2)
go.property("targeting_range", 500)
go.property("level", 1)
go.property("type", 1)

local function sign(n) 
	if n >= 0 then return 1
	else return -1 end
end

function init(self)
	self.d_steer = 0
	self.init_type = battleship_init
	self.update_type = battleship_update
	self.target_type = battleship_target
	if self.type == 2 then
		self.init_type = laser_cutter_init
		self.update_type = laser_cutter_update
		self.target_type = laser_cutter_target
	elseif self.type == 3 then
		self.init_type = missile_cruiser_init
		self.update_type = missile_cruiser_update
		self.target_type = missile_cruiser_target
	end
	self.init_type(self)	
	for i=1,3 do
		if i ~= self.type then
			msg.post("#model_" .. i, "disable")
		end
	end
	msg.post("/manager", "ship_created")
end

function final(self)
	msg.post("/manager", "ship_destroyed")
end

function update(self, dt)
	local max_x, max_y = 1920, 1017
	local pos = go.get_position()
	
	if pos.x > max_x then
		pos.x = max_x
	elseif pos.x < 0 then
		pos.x = 0
	end

	if pos.y > max_y then
		pos.y = max_y
	elseif pos.y < 0 then
		pos.y = 0
	end
	
	self.target_pos = go.get_position("/fleet/target_position")
	local dist_to_target = vmath.length(self.target_pos - pos)
	local vec_to_target = vmath.normalize(self.target_pos - pos)
	if dist_to_target == 0 then
		vec_to_target = vmath.vector3(0, 1, 0)
	end
	
	local d_steer = vmath.cross(vmath.slerp(self.evasion * dt, self.heading, vec_to_target), self.heading).z * 2000
	self.d_steer = vmath.lerp(self.evasion * dt, self.d_steer, d_steer)
	
	self.heading = vmath.normalize(vmath.slerp(self.evasion * dt, self.heading, vec_to_target))
	local angle = math.deg(math.atan2(self.heading.y, self.heading.x)) - 90
	local rot_z = vmath.quat_rotation_z(math.rad(angle))
	local rot_y = vmath.quat_rotation_y(math.rad(self.d_steer))
	go.set_rotation(rot_z * rot_y)

	for i=-3,2 do
		local target = pos + vmath.vector3(math.cos(math.rad(i*30+angle+90+15)), math.sin(math.rad(i*30+angle+90+15)), 0) * self.visibility_range
		local result = physics.raycast(pos, target, { hash("ship_cast") })
		if result ~= nil then
			--msg.post("@render:", "draw_line", {start_point = pos, end_point = result.position, color = vmath.vector4(0, 1, 0, 1)})
			local dist = (self.visibility_range-vmath.length(pos - result.position))/self.visibility_range
			if dist > 1 then dist = 1 end
			self.heading = vmath.normalize(vmath.slerp(self.evasion * dt * dist, 
							self.heading, vmath.normalize(pos - result.position)))
		else
			--msg.post("@render:", "draw_line", {start_point = pos, end_point = target, color = vmath.vector4(1, 0, 0, 1)})
		end
	end
	local res_speed = self.speed
	if dist_to_target < self.visibility_range - 50 then
		res_speed = self.speed * dist_to_target/(self.visibility_range - 50) + 50
	end
	pos = pos + self.heading * res_speed * dt
	go.set_position(pos)

	self.update_type(self, dt)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("target_enemy_response") then
		if message.found then
			self.target_type(self, message)
			--msg.post("@render:", "draw_line", {start_point = go.get_position(), end_point = go.get_position(message.enemy), color = vmath.vector4(1, 0, 0, 1)})
		end
	end
end

function laser_cutter_init(self) 
	self.target_offset = vmath.vector3(0, 0, 0)
	self.evasion = 2 + self.level
	self.speed = 250 + self.level * 100
	--msg.post("#sprite", "play_animation", {id = hash("laser_cutter")})
end

function laser_cutter_update(self, dt)
	self.target_offset = vmath.lerp(dt, self.target_offset, vmath.vector3(0, 0, 0))
	msg.post("/manager", "target_closest_enemy", {pos = go.get_position(), range = self.targeting_range, dt = dt})
end

function laser_cutter_target(self, target) 
	local range_falloff = 1
	if target.found then
		self.target_offset = vmath.lerp(target.dt * 30, self.target_offset, go.get_position(target.enemy) - go.get_position())
		local target_pos = go.get_position() + self.target_offset
		range_falloff = math.sqrt(1 - (vmath.length(go.get_position(target.enemy) - go.get_position()) / self.targeting_range))
		msg.post(target.enemy, "damage_asteroid", {damage = 30 * target.dt * self.level})
		local c = 1 * math.pow(range_falloff, 3)
		msg.post("@render:", "draw_line", {start_point = go.get_position(), end_point = go.get_position() + self.target_offset, color = vmath.vector4(c*2, c/3, c/3, 1)})
	end
end

function battleship_init(self) 
	--msg.post("#sprite", "play_animation", {id = hash("battleship")})
	self.main_cooldown = 4 - self.level/2
	self.small_cooldown = 0.25
	self.charges = 2 + self.level
	self.projectile_speed = 750
end

function battleship_update(self, dt)
	if self.main_cooldown > 0 then 
		self.main_cooldown = self.main_cooldown - dt
	end
	if self.small_cooldown > 0 then 
		self.small_cooldown = self.small_cooldown - dt
	end
	if self.small_cooldown <= 0 and self.main_cooldown <= 0 and self.charges > 0 then
		msg.post("/manager", "target_closest_enemy", {pos = go.get_position(), range = 10000, dt = dt})
	end
end

function battleship_target(self, target) 
	if target.found then
		self.charges = self.charges - 1
		self.small_cooldown = 0.25
		local vec_to_target = vmath.normalize(go.get_position(target.enemy) - go.get_position() + go.get(target.enemy, "velocity") * (vmath.length(go.get_position(target.enemy) - go.get_position()) / self.projectile_speed))
		factory.create("/manager#player_projectile_factory", go.get_position(), nil, {speed = self.projectile_speed, heading = vec_to_target, damage = 30 + self.level*20}, vmath.vector3(0.5))
		if self.charges == 0 then
			self.main_cooldown = 4 - self.level/2
			self.small_cooldown = 0.25
			self.charges = 2 + self.level
		end
	end
end

function missile_cruiser_init(self) 
	--msg.post("#sprite", "play_animation", {id = hash("battleship")})
	self.main_cooldown = 4 - self.level/2
	self.small_cooldown = 0.25
	self.charges = 2 + self.level
	self.projectile_speed = 400
end

function missile_cruiser_update(self, dt)
	if self.main_cooldown > 0 then 
		self.main_cooldown = self.main_cooldown - dt
	end
	if self.small_cooldown > 0 then 
		self.small_cooldown = self.small_cooldown - dt
	end
	if self.small_cooldown <= 0 and self.main_cooldown <= 0 and self.charges > 0 then
		msg.post("/manager", "target_closest_enemy", {pos = go.get_position(), range = 10000, dt = dt})
	end
end

function missile_cruiser_target(self, target) 
	if target.found then
		self.charges = self.charges - 1
		self.small_cooldown = 0.25
		local vec_to_target = vmath.normalize(go.get_position(target.enemy) - go.get_position())
		factory.create("/manager#player_projectile_factory", go.get_position(), nil, 
			{speed = self.projectile_speed, heading = vec_to_target, damage = 30 + self.level*20, 
			target = target.enemy, type = 2}, vmath.vector3(0.5))
		if self.charges == 0 then
			self.main_cooldown = 4 - self.level/2
			self.small_cooldown = 0.25
			self.charges = 2 + self.level
		end
	end
end



