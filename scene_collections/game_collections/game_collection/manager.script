require "modules.utils"
require "modules.class_eval"
require "modules.values.class_bonuses"
require "modules.values.asteroid_score_rewards"

go.property("enemy_count", 0)
go.property("ship_count", 0)
go.property("current_score", 0)

local function url_to_hash(url)
	local str =  hash_to_hex(url.socket or hash("")) .. hash_to_hex(url.path) .. hash_to_hex(url.fragment or hash(""))
	return hash(str)
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.enemies = {}
	self.enemy_count = 0
	self.ships = {}
	self.ship_count = 0
	self.run_data = {}
	self.fleet_data = {}
end

function get_health_percentage_by_type(self, type)
	for k, v in pairs(self.ships) do
		if go.get(v, "type") == type then
			return math.ceil((go.get(v, "health") / go.get(v, "max_health")) * 100)
		end	
	end
	return 0
end

function calculate_credits(self)
	local credit_mult = 0.5 * (1 + self.run_data.extra_credits / 100)
	if self.run_data.difficulty == "hard" then
		credit_mult = credit_mult * 1.25
	elseif self.run_data.difficulty == "very_hard" then
		credit_mult = credit_mult * 1.35
	end
	return math.ceil(self.current_score * credit_mult)
end

function final(self)
	if self.run_data.difficulty == "normal" then

	elseif self.run_data.difficulty == "hard" then
		for k, v in pairs(self.fleet_data) do
			local health_p = get_health_percentage_by_type(self, v.type)
			v.health = math.min(100, health_p + 50)
		end
		msg.post("main:/manager", "save_fleet", {fleet = self.fleet_data})
	else
		for k, v in pairs(self.fleet_data) do
			local health_p = get_health_percentage_by_type(self, v.type)
			v.health = health_p
			if health_p == 0 then
				table.remove(self.fleet_data, k)
			end
		end
		msg.post("main:/manager", "save_fleet", {fleet = self.fleet_data})
	end
	local credit_gain = calculate_credits(self)
	msg.post("main:/manager", "update_credits", {credits = self.run_data.credits + credit_gain})
end

function on_message(self, message_id, message, sender)
	if message_id == hash("enemy_created") then
		self.enemies[url_to_hash(sender)] = sender
		self.enemy_count = self.enemy_count + 1
	elseif message_id == hash("enemy_destroyed") then
		self.enemies[url_to_hash(sender)] = nil
		self.enemy_count = self.enemy_count - 1
		self.current_score = self.current_score + asteroid_score_rewards[go.get(sender, "type")].score_reward
	elseif message_id == hash("ship_created") then
		self.ships[url_to_hash(sender)] = sender
		self.ship_count = self.ship_count + 1
	elseif message_id == hash("ship_destroyed") then
		self.ships[url_to_hash(sender)] = nil
		self.ship_count = self.ship_count - 1
		if self.ship_count <= 0 then
			msg.post("main:/manager", "end_run", {success = false})
			msg.post("main:/manager", "end_from_game")
		end
	elseif message_id == hash("fleet_post_init") then
		self.fleet_data = copy_table(message.fleet)
		local active_class_bonuses = {}
		for k, v in pairs(class_bonuses) do
			active_class_bonuses[k] = 0
		end
		for k, v in pairs(self.ships) do
			if go.get(v, "class_1") ~= hash("") then active_class_bonuses[go.get(v, "class_1")] = active_class_bonuses[go.get(v, "class_1")]+1 end
			if go.get(v, "class_2") ~= hash("") then active_class_bonuses[go.get(v, "class_2")] = active_class_bonuses[go.get(v, "class_2")]+1 end
			if go.get(v, "class_3") ~= hash("") then active_class_bonuses[go.get(v, "class_3")] = active_class_bonuses[go.get(v, "class_3")]+1 end
			msg.post(v, "post_init_ready")
		end
		for k, v in pairs(active_class_bonuses) do
			local bonus_value = get_class_bonus(k, v)
			if bonus_value > 0 then
				for k_cm, cm in pairs(class_bonuses[k].class_masks) do
					msg.post("#", "apply_status_to_fleet", 
					{
						type = "property", property_name = class_bonuses[k].affected_property, 
						value = bonus_value, mix = class_bonuses[k].mix, class_mask = hash(cm)
					})
				end
			end
		end
		msg.post("#", "apply_status_to_fleet", 
		{
			type = "property", property_name = "armor", value = self.run_data.extra_armor, mix = "add"
		})
	elseif message_id == hash("setup") then
		self.run_data = copy_table(message.data)
	elseif message_id == hash("target_closest_enemy") then
		if self.enemy_count > 0 then 
			local shortest_distance = 100000000
			local enemy_url = msg.url()
			local found = false
			for k, v in pairs(self.enemies) do
				local distance = vmath.length(go.get_position(v) - message.pos)
				if distance < shortest_distance and distance < message.range then
					enemy_url = v
					shortest_distance = vmath.length(go.get_position(v) - message.pos)
					found = true
				end
			end
			msg.post(sender, "target_enemy_response", {found = found, enemy = enemy_url, dt = message.dt})
		else 
			msg.post(sender, "target_enemy_response", {found = false})
		end
	elseif message_id == hash("target_closest_ship") then
		if self.ship_count > 0 then 
			local shortest_distance = 100000000
			local ship_url = msg.url()
			local found = false
			for k, v in pairs(self.ships) do
				local distance = vmath.length(go.get_position(v) - message.pos)
				if distance < shortest_distance and distance < message.range then
					ship_url = v
					shortest_distance = vmath.length(go.get_position(v) - message.pos)
					found = true
				end
			end
			msg.post(sender, "target_ship_response", {found = found, ship = ship_url, dt = message.dt})
		else 
			msg.post(sender, "target_ship_response", {found = false})
		end
	elseif message_id == hash("target_ship_by_property") then
		if self.ship_count > 0 then 
			local closest = 100000000
			if message.get_by == "highest" then closest = 0 end
			local ship_url = msg.url()
			local found = false
			for k, v in pairs(self.ships) do
				local prop_value = go.get(v, message.property)
				if message.get_by == "highest" and prop_value > closest or message.get_by == "lowest" and prop_value < closest then
					ship_url = v
					closest = prop_value
					found = true
				end
			end
			msg.post(sender, "target_ship_response", {found = found, ship = ship_url, dt = message.dt})
		else 
			msg.post(sender, "target_ship_response", {found = false})
		end
	elseif message_id == hash("apply_status_to_fleet") then
		if message.type == "property" then
			for k, v in pairs(self.ships) do
				if message.class_mask == nil or message.class_mask == hash("all") or message.class_mask == go.get(v, "class_1") or message.class_mask == go.get(v, "class_2") or message.class_mask == go.get(v, "class_2") then
					local current_value = go.get(v, message.property_name)
					if message.mix == "add" then
						go.set(v, message.property_name, current_value + message.value)
					elseif message.mix == "multiply" then
						go.set(v, message.property_name, current_value * message.value)
					end
				end
			end
		end
	elseif message_id == hash("stage_done") then
		msg.post("/gui_container#game", "show_stage_done", {credits = calculate_credits(self)})
	end
end

function on_input(self, action_id, action)
	if action_id == hash("space") and action.released then
		local width, height = 1920, 1017
		if math.random() > 0.5 then
			local lr = math.random(0, 1)
			local p = vmath.vector3(-100 + (width+200) * lr, math.random(-100, height+100), 0)
			local props = {}
			props[hash("/base_asteroid")] = {initial_slowdown = 2}
			local ids = collectionfactory.create("#asteroid_collection_factory", p, nil, props)
			local velocity = vmath.vector3(0, math.random(-height, height), 0)
			local url = msg.url(nil, ids[hash("/base_asteroid")], "co3")
			msg.post(url, "apply_force", {force = velocity * 30, position = p + vmath.vector3(math.random(-20, 20), math.random(-20, 20), 0)})
		else 
			local ud = math.random(0, 1)
			local p = vmath.vector3(math.random(-100, width+100), -100 + (height+200) * ud, 0)
			local props = {}
			props[hash("/base_asteroid")] = {initial_slowdown = 2}
			local ids = collectionfactory.create("#asteroid_collection_factory", p, nil, props)
			local velocity = vmath.vector3(0, math.random(-height, height), 0)
			local url = msg.url(nil, ids[hash("/base_asteroid")], "co3")
			msg.post(url, "apply_force", {force = velocity * 30, position = p + vmath.vector3(math.random(-20, 20), math.random(-20, 20), 0)})
		end
	end
end