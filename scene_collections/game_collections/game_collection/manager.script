require "modules.utils"
require "modules.class_eval"
require "modules.values.class_bonuses"
require "modules.values.asteroid_score_rewards"

go.property("enemy_count", 0)
go.property("ship_count", 0)
go.property("current_score", 0)

go.property("physical_damage_mult", 1)
go.property("explosive_damage_mult", 1)
go.property("energy_damage_mult", 1)
go.property("aoe_range_mult", 1)

local function url_to_hash(url)
	local str =  hash_to_hex(url.socket or hash("")) .. hash_to_hex(url.path) .. hash_to_hex(url.fragment or hash(""))
	return hash(str)
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.enemies = {}
	self.enemy_count = 0
	self.ships = {}
	self.ship_count = 0
	self.run_data = {}
	self.fleet_data = {}
end

function get_health_percentage_by_type(self, type)
	for k, v in pairs(self.ships) do
		if go.get(v, "type") == type then
			return math.ceil((go.get(v, "health") / go.get(v, "max_health")) * 100)
		end	
	end
	return 0
end

function calculate_credits(self)
	local credit_mult = 0.5 * (1 + self.run_data.extra_credits / 100)
	if self.run_data.difficulty == "hard" then
		credit_mult = credit_mult * 1.25
	elseif self.run_data.difficulty == "very_hard" then
		credit_mult = credit_mult * 1.35
	end
	return math.ceil(self.current_score * credit_mult)
end

function apply_status_to_manager(data, value) 
	local current = go.get("#", data.affected_property)
	if data.mix == "add" then
		current = current + value
	elseif data.mix == "multiply" then
		current = current * value
	end
	go.set("#", data.affected_property, current)
end

function final(self)
	if self.run_data.difficulty == "normal" then

	elseif self.run_data.difficulty == "hard" then
		for k, v in pairs(self.fleet_data) do
			local health_p = get_health_percentage_by_type(self, v.type)
			v.health = math.min(100, health_p + 50)
		end
		msg.post("main:/manager", "save_fleet", {fleet = self.fleet_data})
	else
		for k, v in pairs(self.fleet_data) do
			local health_p = get_health_percentage_by_type(self, v.type)
			v.health = health_p
			if health_p == 0 then
				table.remove(self.fleet_data, k)
			end
		end
		msg.post("main:/manager", "save_fleet", {fleet = self.fleet_data})
	end
	local credit_gain = calculate_credits(self)
	msg.post("main:/manager", "update_credits", {credits = self.run_data.credits + credit_gain})
end

function on_message(self, message_id, message, sender)
	if message_id == hash("enemy_created") then
		self.enemies[url_to_hash(sender)] = sender
		self.enemy_count = self.enemy_count + 1
	elseif message_id == hash("enemy_destroyed") then
		self.enemies[url_to_hash(sender)] = nil
		self.enemy_count = self.enemy_count - 1
		self.current_score = self.current_score + asteroid_score_rewards[go.get(sender, "type")].score_reward
	elseif message_id == hash("ship_created") then
		self.ships[url_to_hash(sender)] = sender
		self.ship_count = self.ship_count + 1
	elseif message_id == hash("ship_destroyed") then
		self.ships[url_to_hash(sender)] = nil
		self.ship_count = self.ship_count - 1
		if self.ship_count <= 0 then
			msg.post("main:/manager", "end_run", {success = false})
			msg.post("main:/manager", "end_from_game")
		end
	elseif message_id == hash("fleet_post_init") then
		self.fleet_data = copy_table(message.fleet)
		local active_class_bonuses = {}
		for k, v in pairs(class_bonuses) do
			active_class_bonuses[k] = 0
		end
		for k, v in pairs(self.ships) do
			if go.get(v, "class_1") ~= hash("") then active_class_bonuses[go.get(v, "class_1")] = active_class_bonuses[go.get(v, "class_1")]+1 end
			if go.get(v, "class_2") ~= hash("") then active_class_bonuses[go.get(v, "class_2")] = active_class_bonuses[go.get(v, "class_2")]+1 end
			if go.get(v, "class_3") ~= hash("") then active_class_bonuses[go.get(v, "class_3")] = active_class_bonuses[go.get(v, "class_3")]+1 end
			msg.post(v, "post_init_ready")
		end
		for k, v in pairs(active_class_bonuses) do
			local bonus_value = get_class_bonus(k, v)
			if bonus_value > 0 then
				for k_cm, cm in pairs(class_bonuses[k].class_masks) do
					if class_bonuses[k].target == "fleet" then
						msg.post("#", "apply_status_to_fleet", 
						{
							type = "property", property_name = class_bonuses[k].affected_property, 
							value = bonus_value, mix = class_bonuses[k].mix, class_mask = hash(cm)
						})
					elseif class_bonuses[k].target == "manager" then
						apply_status_to_manager(class_bonuses[k], bonus_value)
					end
				end
			end
		end
		msg.post("#", "apply_status_to_fleet", 
		{
			type = "property", property_name = "armor", value = self.run_data.extra_armor, mix = "add"
		})
	elseif message_id == hash("setup") then
		self.run_data = copy_table(message.data)
	elseif message_id == hash("target_all_enemies") then
		enemies = {}
		for k, v in pairs(self.enemies) do
			table.insert(enemies, v)
		end
		msg.post(sender, "target_enemy_response", {found = #enemies>0, enemies = enemies, dt = message.dt})
	elseif message_id == hash("target_random_enemy") then
		keyset = {}
		local found = false
		for k, v in pairs(self.enemies) do
			found = true
			table.insert(keyset, k)
		end
		if found then
			msg.post(sender, "target_enemy_response", {found = found, enemy = self.enemies[keyset[math.random(#keyset)]], dt = message.dt})
		else
			msg.post(sender, "target_enemy_response", {found = found, enemy = nil, dt = message.dt})
		end
	elseif message_id == hash("target_closest_enemy") then
		if self.enemy_count > 0 then 
			local shortest_distance = 100000000
			local enemy_url = msg.url()
			local found = false
			for k, v in pairs(self.enemies) do
				local distance = vmath.length(go.get_position(v) - message.pos)
				if distance < shortest_distance and distance < message.range then
					enemy_url = v
					shortest_distance = vmath.length(go.get_position(v) - message.pos)
					found = true
				end
			end
			msg.post(sender, "target_enemy_response", {found = found, enemy = enemy_url, dt = message.dt})
		else 
			msg.post(sender, "target_enemy_response", {found = false})
		end
	elseif message_id == hash("target_k_closest_enemies") then
		if self.enemy_count > 0 then 
			local enemies = {}
			local found = false
			for key, v in pairs(self.enemies) do
				local distance = vmath.length(go.get_position(v) - message.pos)
				if #enemies < message.k and distance < message.range then
					table.insert(enemies, {v, distance})
					found = true
				elseif distance < message.range then
					max_key = 1
					for ms_key, ms_v in pairs(enemies) do
						if ms_v[2] > enemies[max_key][2] then
							max_key = ms_key
						end
					end
					enemies[max_key] = {v, distance}
				end
			end
			msg.post(sender, "target_enemy_response", {found = found, enemies = enemies, dt = message.dt})
		else 
			msg.post(sender, "target_enemy_response", {found = false})
		end
	elseif message_id == hash("target_closest_ship") then
		if self.ship_count > 0 then 
			local shortest_distance = 100000000
			local ship_url = msg.url()
			local found = false
			for k, v in pairs(self.ships) do
				local distance = vmath.length(go.get_position(v) - message.pos)
				if distance < shortest_distance and distance < message.range then
					ship_url = v
					shortest_distance = vmath.length(go.get_position(v) - message.pos)
					found = true
				end
			end
			msg.post(sender, "target_ship_response", {found = found, ship = ship_url, dt = message.dt})
		else 
			msg.post(sender, "target_ship_response", {found = false})
		end
	elseif message_id == hash("target_ship_by_property") then
		if self.ship_count > 0 then 
			local closest = 100000000
			if message.get_by == "highest" then closest = 0 end
			local ship_url = msg.url()
			local found = false
			for k, v in pairs(self.ships) do
				local prop_value = go.get(v, message.property)
				if message.get_by == "highest" and prop_value > closest or message.get_by == "lowest" and prop_value < closest then
					ship_url = v
					closest = prop_value
					found = true
				end
			end
			msg.post(sender, "target_ship_response", {found = found, ship = ship_url, dt = message.dt})
		else 
			msg.post(sender, "target_ship_response", {found = false})
		end
	elseif message_id == hash("apply_status_to_fleet") then
		if message.type == "property" then
			for k, v in pairs(self.ships) do
				if message.class_mask == nil or message.class_mask == hash("all") or message.class_mask == go.get(v, "class_1") or message.class_mask == go.get(v, "class_2") or message.class_mask == go.get(v, "class_2") then
					local current_value = go.get(v, message.property_name)
					if message.mix == "add" then
						go.set(v, message.property_name, current_value + message.value)
					elseif message.mix == "multiply" then
						go.set(v, message.property_name, current_value * message.value)
					end
				end
			end
		end
	elseif message_id == hash("create_player_projectile") then
		factory.create("#player_projectile_factory", message.position, nil, message.properties, message.scale)
	elseif message_id == hash("create_player_mine") then
		factory.create("#player_mine_factory", message.position, nil, message.properties, message.scale)
	elseif message_id == hash("create_player_aoe") then
		factory.create("#player_aoe_factory", message.position, message.rotation, message.properties, message.scale * self.aoe_range_mult)		
	elseif message_id == hash("apply_status_to_manager") then
		apply_status_to_manager(message, message.value)
	elseif message_id == hash("stage_done") then
		msg.post("/gui_container#game", "show_stage_done", {credits = calculate_credits(self)})
	end
end

function on_input(self, action_id, action)
	-- Debug asteroid spawn
	if action_id == hash("space") and action.released then
		if math.random() > 0.5 then
			local lr = math.random(0, 1)
			local p = vmath.vector3(-100 + (WIDTH+200) * lr, math.random(-100, HEIGHT+100), 0)
			local props = {}
			props[hash("/base_asteroid")] = {initial_slowdown = 2}
			local ids = collectionfactory.create("#asteroid_collection_factory", p, nil, props)
			local velocity = vmath.vector3(0, math.random(-HEIGHT, HEIGHT), 0)
			local url = msg.url(nil, ids[hash("/base_asteroid")], "co3")
			msg.post(url, "apply_force", {force = velocity * 30, position = p + vmath.vector3(math.random(-20, 20), math.random(-20, 20), 0)})
		else 
			local ud = math.random(0, 1)
			local p = vmath.vector3(math.random(-100, WIDTH+100), -100 + (HEIGHT+200) * ud, 0)
			local props = {}
			props[hash("/base_asteroid")] = {initial_slowdown = 2}
			local ids = collectionfactory.create("#asteroid_collection_factory", p, nil, props)
			local velocity = vmath.vector3(0, math.random(-HEIGHT, HEIGHT), 0)
			local url = msg.url(nil, ids[hash("/base_asteroid")], "co3")
			msg.post(url, "apply_force", {force = velocity * 30, position = p + vmath.vector3(math.random(-20, 20), math.random(-20, 20), 0)})
		end
	end
end